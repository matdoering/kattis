== 10kindsofpeople

See https://open.kattis.com/problems/10kindsofpeople/statistics

=== Summary

A map is provided by an input file (see `data` folder):
* Binary zone: `0`
* Decimal zone: `1`

- Users of binary have to stay in binary zones
- Users of decimal have to stay in decimal zones

The input file encodes several queries representing a routing request from one point in the map to another.
For each query: 

- Output `binary` if a binary user can move from source to target
- Output `decimal`: if this is the case for a decimal user
- Output `neither`: otherwise

Possible movements are: N/E/S/W

=== Solution Strategies

All solution strategies are based on breadth-first search (BFS), however, with different implementation choices.
The implemented strategies described in the following sections are sorted according to decreasing runtime.
Runtimes were calculated for a reference sample file and are reported in miliseconds.

==== A: Explicit Graph Generation (32800 ms)

In this solution strategy, the graph structure for BFS is build explicitly. That is, after parsing the input data,
the graph layout is generated by walking through the whole input data. Thereafter,
BFS is executed on the graph to find whether there is a route.

This implementation is very slow because building the graph has a quadratic runtime, assuming that
the map has the same number of rows as columns.

==== B: Implicit Graph Generation (Runtime 3447 ms)

This approach improves strategy A by implicitly generating the graph. That is, possible traversal nodes
are generated on-the-fly during BFS. 

This implementation is faster because the runtime is now dominated by the time it takes for BFS to
either find the target or terminate after having gone through all reachable nodes, which is usually much
faster than quadratic.

==== C: Use of Historic Information (Runtime 200 ms)

Since route searching is performed on the same map for multiple queries, we can store the information
that we acquired in previous runs. The main idea is that each run of BFS defines an equivalence
class of reachability. If we have this information, we can distinguish two cases:

- Nodes have the same reachability equivalence class: We can output a result (either `binary` or `decimal`) in constant runtime.
- Nodes have different reachbility equivalence classes: We can output `neither` because it's not possible to find a route.

If we don't have the equivalence relationship data yet, we run BFS to find the solution. 

An additional benefit of this approach is that we don't need an explicit closed list but can use
the information from previous runs. This further reduces the runtime because fewer nodes have
to be considered during BFS.

This implementation is much faster than the others for the following reasons (highest impact to lowest):

- Reachability data is reused, so for some queries we don't need to calculate anything
- If we have to calculate something, we usually have to consider fewer options during BFS due to prior knowledge


=== How to build and run?

 make && ./Solver {sampleFile}

Data can be read from file or from standard input. For example:

 ./Solver data/sample-01.in
 ./Solver < data/sample-01.in

Results for each query are written to the console.

